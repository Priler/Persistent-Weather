-- [ Persistent Weather ]--
-- caches weather on save, restores on load to prevent random transitions
-- original by Yohji
-- re-written for Anomaly 1.5.3 by Abraham (Priler)

local cached_weather = nil
local cached_cycle = nil
local underground_enter_time = nil
local first_select = true

-- rain sound fallback (bypasses broken vanilla CEffect_Rain sound)
local rain_sound = nil
local rain_sound_started = false
local rain_check_count = 0

-- [ MCM ]--

local function get_config(key)
    if priler_persistent_weather_mcm then
        return priler_persistent_weather_mcm.get_config(key)
    end
    -- defaults if MCM not available
    local defaults = {
        enabled = true,
        level_change_persist_chance = 0,
        level_change_min_delay = 0,
        underground_timeout = 10,
        replace_rain_sound = false,
        debug_mode = false,
    }
    return defaults[key]
end

local function dbg(fmt, ...)
    if get_config("debug_mode") then
        local msg = string.format(fmt, ...)
        printf("~ pw: " .. msg)
    end
end

local function get_underground_timeout_ms()
    return get_config("underground_timeout") * 60 * 1000
end

local function should_persist_on_level_change()
    local chance = get_config("level_change_persist_chance")
    if chance <= 0 then return false end
    if chance >= 100 then return true end
    return math.random(100) <= chance
end

-- [ Helpers ]--

local function is_underground()
    return level_weathers.bLevelUnderground
end

-- extract cycle name from preset (e.g. "w_clear1" -> "clear")
local function get_cycle_from_preset(preset)
    if not preset then return nil end
    for _, cycle in ipairs({"clear", "partly", "cloudy", "rainy", "stormy", "foggy"}) do
        if string.find(preset, cycle) then
            return cycle
        end
    end
    return nil
end

-- [ Rain Sound System ]--
-- Two modes:
-- 1. Fallback mode (default): detect when engine sound dies, play our own
-- 2. Replacement mode (MCM option): take over rain sound completely (requires silent rain.ogg)

local rain_sound = nil
local rain_sound_started = false
local rain_check_count = 0
local current_volume = 0
local FADE_SPEED = 2.0  -- how fast volume fades (higher = faster)
local RAIN_SOUND_PATH = "ambient\\pw_rain"  -- our own file, doesn't conflict with engine
local sound_start_time = 0  -- when sound was started (for health check grace period)

local function stop_rain_sound()
    if rain_sound then
        if rain_sound:playing() then
            rain_sound:stop()
            dbg("rain sound stopped")
        end
        rain_sound = nil
    end
    rain_sound_started = false
    current_volume = 0
    sound_start_time = 0
end

local function start_rain_sound()
    if rain_sound_started then return end
    if not db.actor then
        printf("~ pw: ERROR - cannot start rain sound, no actor")
        return
    end
    
    local snd = sound_object(RAIN_SOUND_PATH)
    if not snd then
        printf("~ pw: ERROR - could not create sound object [%s]", RAIN_SOUND_PATH)
        return
    end
    
    snd:play(db.actor, 0, sound_object.s2d + sound_object.looped)
    snd.volume = 0.5  -- start at audible volume for debugging
    
    rain_sound = snd
    rain_sound_started = true
    sound_start_time = time_global()
    dbg("rain sound started [%s]", RAIN_SOUND_PATH)
end

-- fallback mode: only activate when engine sound is stuck
local function update_rain_sound_fallback()
    -- don't run fallback if replacement mode is active
    if get_config("replace_rain_sound") then
        return true -- stop timer
    end
    
    if is_underground() then
        stop_rain_sound()
        rain_check_count = 0
        return true -- stop monitoring underground
    end
    
    local rain_density = level.rain_factor()
    local rain_volume = level.get_rain_volume()
    
    -- no rain expected
    if rain_density < 0.2 then
        stop_rain_sound()
        rain_check_count = 0
        return true -- stop monitoring
    end
    
    rain_check_count = rain_check_count + 1
    
    -- engine sound working fine
    if rain_volume >= 0.2 then
        if rain_sound_started then
            stop_rain_sound()
        end
        if rain_check_count > 10 then
            return true -- confirmed working, stop monitoring
        end
        return false -- keep checking
    end
    
    -- rain expected but volume stuck
    if rain_check_count > 6 then
        if not rain_sound_started then
            start_rain_sound()
        end
        if rain_sound and rain_sound:playing() then
            rain_sound.volume = math.min(rain_density * 0.7, 0.8)
        end
    end
    
    return false -- keep monitoring
end

local function on_rain_sound_timer()
    if not db.actor then return false end
    
    -- timer only used for fallback mode now
    -- replacement mode uses actor_on_update
    return update_rain_sound_fallback()
end

local function start_rain_sound_monitor()
    rain_check_count = 0
    RemoveTimeEvent("persistent_weather", "rain_sound")
    local interval = 0.5
    dbg("starting rain monitor (fallback mode)")
    CreateTimeEvent("persistent_weather", "rain_sound", interval, on_rain_sound_timer)
end

-- replacement mode: runs every frame via actor_on_update
local function on_actor_update()
    if not get_config("replace_rain_sound") then return end
    if not db.actor then return end  -- actor not ready yet
    
    local rain_factor = level.rain_factor()
    local rain_volume = level.get_rain_volume()
    
    -- warmup fix: engine's hemi_factor needs time to stabilize after load
    -- if volume is suspiciously low compared to rain_factor, override it
    -- this happens for ~2-3 seconds after load while hemi_factor lerps up
    if rain_factor > 0.1 and rain_volume < rain_factor * 0.3 then
        rain_volume = rain_factor * 0.6  -- reasonable outdoor volume
    end
    
    -- determine target volume
    local target_volume = 0
    if not is_underground() and rain_factor >= 0.01 then
        target_volume = rain_volume
    end
    
    -- start sound if needed
    if target_volume > 0 and not rain_sound_started then
        dbg("replacement mode - starting rain (factor=%s, vol=%s)", tostring(rain_factor), tostring(target_volume))
        start_rain_sound()
        if not rain_sound_started then
            return
        end
        current_volume = 0.5  -- match start_rain_sound initial volume
        -- verify sound is actually playing
        if rain_sound then
            dbg("sound check after start: playing=%s volume=%.2f", tostring(rain_sound:playing()), rain_sound.volume)
        end
    end
    
    -- health check: if sound should be playing but died, restart it
    -- only check after 500ms grace period (playing() returns false right after play())
    if rain_sound_started and target_volume > 0 then
        local time_since_start = time_global() - sound_start_time
        if time_since_start > 500 then
            if not rain_sound or not rain_sound:playing() then
                dbg("sound died unexpectedly, restarting...")
                rain_sound_started = false
                rain_sound = nil
                start_rain_sound()
                if rain_sound_started then
                    current_volume = target_volume  -- restore volume immediately
                end
                return
            end
        end
    end
    
    -- smooth volume transition
    if rain_sound_started and rain_sound then
        local diff = target_volume - current_volume
        
        if math.abs(diff) < 0.01 then
            current_volume = target_volume
        else
            -- lerp towards target
            local delta = device().time_delta / 1000  -- convert ms to seconds
            current_volume = current_volume + diff * FADE_SPEED * delta
            current_volume = math.max(0, math.min(1, current_volume))  -- clamp 0-1
        end
        
        -- debug: log volume every ~1 second
        if not _pw_last_vol_log then _pw_last_vol_log = 0 end
        if time_global() - _pw_last_vol_log > 1000 then
            dbg("volume: current=%.2f target=%.2f playing=%s", current_volume, target_volume, tostring(rain_sound:playing()))
            _pw_last_vol_log = time_global()
        end
        
        rain_sound.volume = current_volume
        
        -- stop sound after fade out completes
        if current_volume < 0.01 and target_volume == 0 then
            stop_rain_sound()
            current_volume = 0
        end
    end
end

local function reset_rain_sound_state()
    if rain_sound then
        if rain_sound:playing() then
            rain_sound:stop()
        end
        rain_sound = nil
    end
    rain_sound_started = false
    current_volume = 0
    sound_start_time = 0
end

function on_game_start()
    RegisterScriptCallback("actor_on_update", on_actor_update)
    RegisterScriptCallback("actor_on_first_update", reset_rain_sound_state)
    
    -- clean up any leftover sound from previous session
    reset_rain_sound_state()
    
    printf("~ pw: initialized (replace_rain_sound=%s, debug=%s)", 
        tostring(get_config("replace_rain_sound")), 
        tostring(get_config("debug_mode")))
end

-- [ WeatherManager Hooks ]--

local original_select_weather = level_weathers.WeatherManager.select_weather
level_weathers.WeatherManager.select_weather = function(self, now)
    
    -- check if mod is enabled
    if not get_config("enabled") then
        return original_select_weather(self, now)
    end
    
    -- let vanilla handle weather effects (emissions, psi-storms)
    if self.weather_fx then
        cached_weather = nil
        cached_cycle = nil
        first_select = false
        return original_select_weather(self, now)
    end
    
    -- if underground, track time and allow gradual weather transition
    if is_underground() and cached_weather then
        if not underground_enter_time then
            underground_enter_time = time_global()
        end
        
        local ms_underground = time_global() - underground_enter_time
        
        if ms_underground > get_underground_timeout_ms() then
            printdbg("~ persistent_weather: underground for %d sec, allowing transition", ms_underground / 1000)
            cached_weather = nil
            cached_cycle = nil
            underground_enter_time = nil
        end
    end
    
    -- on first select after load, inject our cached weather (like original Yohji mod)
    if first_select and cached_weather and not is_underground() then
        first_select = false
        
        local target_weather = cached_weather
        local target_cycle = cached_cycle
        
        -- clear cache immediately
        cached_weather = nil
        cached_cycle = nil
        underground_enter_time = nil
        
        -- set weather IMMEDIATELY to prevent nil window (other mods may query weather)
        level.set_weather(target_weather, true)
        self.weather_file = target_weather
        if target_cycle then
            self.cycle = target_cycle
        end
        self:set_brightness_boosts()
        
        printdbg("~ persistent_weather: restored [%s] cycle [%s]", target_weather, tostring(target_cycle))
        
        -- start rain sound fallback monitor (only if not using replacement mode)
        if not get_config("replace_rain_sound") then
            CreateTimeEvent("persistent_weather", "rain_monitor", 0.3, function()
                start_rain_sound_monitor()
                return true
            end)
        end
        
        return -- early return like original mod
    end
    
    first_select = false
    
    -- keep cache updated for potential level change persistence
    if get_config("level_change_persist_chance") > 0 and not is_underground() then
        CreateTimeEvent("persistent_weather", "update_cache", 0.1, function()
            local current = level.get_weather()
            if current and current ~= "" then
                cached_weather = current
                cached_cycle = self.cycle or get_cycle_from_preset(current)
            end
            return true
        end)
    end
    
    -- start rain sound fallback monitor for vanilla loads too (only if not using replacement mode)
    if not get_config("replace_rain_sound") then
        start_rain_sound_monitor()
    end
    
    return original_select_weather(self, now)
end

local original_load_state = level_weathers.WeatherManager.load_state
level_weathers.WeatherManager.load_state = function(self, m_data)
    first_select = true
    
    if not m_data or not get_config("enabled") then
        return original_load_state(self, m_data)
    end
    
    local pw = m_data.persistent_weather
    if pw then
        cached_weather = pw.preset
        cached_cycle = pw.cycle
        
        -- detect level change by comparing saved level with current
        local saved_level = pw.level
        local current_level = level.name()
        
        if saved_level and saved_level ~= current_level then
            -- level changed! check if minimum delay passed
            local min_delay = get_config("level_change_min_delay") * 60 -- convert to seconds
            local time_since_save = 0
            
            if pw.save_time then
                local saved_time = utils_data.CTime_from_table(pw.save_time)
                if saved_time then
                    time_since_save = game.get_game_time():diffSec(saved_time)
                end
            end
            
            if min_delay > 0 and time_since_save < min_delay then
                -- not enough time passed, keep weather
                printdbg("~ persistent_weather: level change [%s]->[%s], keeping [%s] (delay: %ds/%ds)", 
                    saved_level, current_level, cached_weather, time_since_save, min_delay)
            elseif should_persist_on_level_change() then
                printdbg("~ persistent_weather: level change [%s]->[%s], keeping [%s] (roll succeeded)", saved_level, current_level, cached_weather)
            else
                printdbg("~ persistent_weather: level change [%s]->[%s], allowing new weather (roll failed)", saved_level, current_level)
                cached_weather = nil
                cached_cycle = nil
            end
        end
        
        if is_underground() then
            underground_enter_time = time_global()
        else
            underground_enter_time = nil
        end
        
        if cached_weather then
            printdbg("~ persistent_weather: loaded [%s] cycle [%s]", cached_weather, tostring(cached_cycle))
        end
    end
    
    return original_load_state(self, m_data)
end

local original_save_state = level_weathers.WeatherManager.save_state
level_weathers.WeatherManager.save_state = function(self, m_data)
    original_save_state(self, m_data)
    
    if not get_config("enabled") then
        return
    end
    
    local current_level = level.name()
    local current_time = utils_data.CTime_to_table(game.get_game_time())
    
    if not is_underground() then
        if level.is_wfx_playing() then
            -- during weather fx, preserve cached weather if we have it
            if cached_weather then
                m_data.persistent_weather = {
                    preset = cached_weather,
                    cycle = cached_cycle,
                    level = current_level,
                    save_time = current_time
                }
            end
            return
        end
        
        local current = level.get_weather()
        if current and current ~= "" then
            m_data.persistent_weather = {
                preset = current,
                cycle = self.cycle or get_cycle_from_preset(current),
                level = current_level,
                save_time = current_time
            }
            printdbg("~ persistent_weather: saved [%s] cycle [%s] level [%s]", current, tostring(m_data.persistent_weather.cycle), current_level)
        end
    else
        -- underground, preserve cached weather
        if cached_weather then
            m_data.persistent_weather = {
                preset = cached_weather,
                cycle = cached_cycle,
                level = current_level,
                save_time = current_time
            }
        end
    end
end
